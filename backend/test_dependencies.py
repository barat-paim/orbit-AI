import numpy as np
import pandas as pd
import matplotlib
matplotlib.use('Agg')  # Set non-interactive backend
import matplotlib.pyplot as plt
import seaborn as sns
import scipy.stats as stats
from scipy import optimize, interpolate
import statsmodels.api as sm
import json
from datetime import datetime, timedelta

def test_code_execution_environment():
    """Test the exact environment used by the FastAPI server for code execution"""
    print("Testing code execution environment...")
    
    # Create sample data similar to what the server uses
    data = [
        {"time": 1734371573.238, "wpm": 87.04, "accuracy": 0.98},
        {"time": 1734371515.965, "wpm": 87.97, "accuracy": 0.99}
    ]
    df = pd.DataFrame(data)
    df['timestamp'] = pd.to_datetime(df['time'], unit='s')
    
    # Test code that might be generated by Claude
    test_code = """
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy import stats

# Calculate basic statistics
mean_wpm = df['wpm'].mean()
std_wpm = df['wpm'].std()

# Create a visualization
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='timestamp', y='wpm')
plt.title('WPM over Time')
plt.close()

# Perform statistical test
stat, p_value = stats.normaltest(df['wpm'])

result = {
    'mean_wpm': mean_wpm,
    'std_wpm': std_wpm,
    'normality_test_p_value': p_value
}
"""
    
    try:
        # Setup execution environment like the server does
        local_ns = {
            'pd': pd,
            'df': df,
            'plt': plt,
            'sns': sns,
            'np': np,
            'stats': stats,
            'result': None
        }
        
        # Execute code
        exec(test_code, local_ns)
        print("Code execution successful!")
        print("Results:", local_ns.get('result', None))
        
    except Exception as e:
        print("Code execution failed:", str(e))
        return False
    
    return True

def test_common_plotting_scenario():
    """Test the most common plotting scenario that works reliably"""
    print("\nTesting common plotting scenario...")
    
    # Create sample typing data
    data = {
        'wpm': [87.04, 85.97, 90.23, 82.45, 88.67],
        'accuracy': [0.97, 0.96, 0.95, 0.94, 0.97]
    }
    df = pd.DataFrame(data)
    
    try:
        # Create plot
        plt.figure(figsize=(10, 6))
        
        # Scatter plot
        sns.scatterplot(data=df, x='wpm', y='accuracy')
        
        # Add trend line
        x = df['wpm']
        y = df['accuracy']
        z = np.polyfit(x, y, 1)
        p = np.poly1d(z)
        plt.plot(x, p(x), "r--", alpha=0.8)
        
        plt.title('Speed vs Accuracy with Trend Line')
        plt.xlabel('Words per Minute (WPM)')
        plt.ylabel('Accuracy')
        
        plt.close()
        print("Common plotting scenario successful!")
        return True
    except Exception as e:
        print("Common plotting scenario failed:", str(e))
        return False

def test_statistical_analysis_scenario():
    """Test a scenario that requires scipy for statistical analysis"""
    print("\nTesting statistical analysis scenario...")
    
    # Create sample typing data
    data = {
        'wpm': [87.04, 85.97, 90.23, 82.45, 88.67, 91.23, 86.45, 89.78, 84.56, 92.34],
        'accuracy': [0.97, 0.96, 0.95, 0.94, 0.97, 0.96, 0.98, 0.95, 0.93, 0.96]
    }
    df = pd.DataFrame(data)
    
    try:
        # Statistical Analysis
        correlation, p_value = stats.pearsonr(df['wpm'], df['accuracy'])
        print(f"Correlation coefficient: {correlation:.4f}, p-value: {p_value:.4f}")
        
        # Linear regression with confidence intervals
        slope, intercept, r_value, p_value, std_err = stats.linregress(df['wpm'], df['accuracy'])
        
        # Create confidence interval lines
        x = df['wpm']
        y = df['accuracy']
        n = len(df)
        mean_x = np.mean(x)
        
        # Calculate confidence intervals
        conf_interval = 0.95
        degrees_of_freedom = n - 2
        t_value = stats.t.ppf((1 + conf_interval) / 2, degrees_of_freedom)
        
        # Plotting
        plt.figure(figsize=(10, 6))
        
        # Scatter plot
        sns.scatterplot(data=df, x='wpm', y='accuracy')
        
        # Regression line
        y_pred = slope * x + intercept
        plt.plot(x, y_pred, 'r-', label=f'Regression line (R² = {r_value**2:.4f})')
        
        # Confidence intervals
        x_new = np.linspace(x.min(), x.max(), 100)
        y_new = slope * x_new + intercept
        
        # Standard error of regression
        std_error = np.sqrt(np.sum((y - y_pred)**2) / degrees_of_freedom)
        
        # Confidence interval
        ci = t_value * std_error * np.sqrt(1/n + (x_new - mean_x)**2 / np.sum((x - mean_x)**2))
        plt.fill_between(x_new, y_new - ci, y_new + ci, color='red', alpha=0.1, label='95% Confidence Interval')
        
        plt.title('Speed vs Accuracy with Regression Line and Confidence Intervals')
        plt.xlabel('Words per Minute (WPM)')
        plt.ylabel('Accuracy')
        plt.legend()
        
        plt.close()
        print("Statistical analysis scenario successful!")
        return True
    except Exception as e:
        print("Statistical analysis scenario failed:", str(e))
        return False

def test_statsmodels_analysis():
    """Test statsmodels functionality for advanced statistical analysis"""
    print("\nTesting statsmodels analysis...")
    
    # Create sample typing data
    data = {
        'wpm': [87.04, 85.97, 90.23, 82.45, 88.67, 91.23, 86.45, 89.78, 84.56, 92.34],
        'accuracy': [0.97, 0.96, 0.95, 0.94, 0.97, 0.96, 0.98, 0.95, 0.93, 0.96]
    }
    df = pd.DataFrame(data)
    
    try:
        # Prepare data for statsmodels
        X = sm.add_constant(df['wpm'])
        model = sm.OLS(df['accuracy'], X)
        results = model.fit()
        
        # Get confidence intervals
        predictions = results.get_prediction(X)
        ci = predictions.conf_int()
        
        # Plotting
        plt.figure(figsize=(10, 6))
        
        # Scatter plot
        plt.scatter(df['wpm'], df['accuracy'], color='blue', alpha=0.5)
        
        # Regression line
        plt.plot(df['wpm'], results.fittedvalues, 'r-', label=f'Regression line (R² = {results.rsquared:.4f})')
        
        # Confidence intervals
        plt.fill_between(df['wpm'], ci[:, 0], ci[:, 1], color='red', alpha=0.1, label='95% Confidence Interval')
        
        plt.title('Speed vs Accuracy with Regression Line and Confidence Intervals (statsmodels)')
        plt.xlabel('Words per Minute (WPM)')
        plt.ylabel('Accuracy')
        plt.legend()
        
        plt.close()
        
        # Print statistical summary
        print("\nRegression Statistics:")
        print(f"R-squared: {results.rsquared:.4f}")
        print(f"P-value: {results.f_pvalue:.4f}")
        print("Statistical analysis with statsmodels successful!")
        return True
    except Exception as e:
        print("Statsmodels analysis failed:", str(e))
        return False

def test_all_dependencies():
    # Test statsmodels functionality first
    print("Testing statsmodels functionality...")
    if not test_statsmodels_analysis():
        print("Warning: Statsmodels analysis failed!")
    
    # Test the statistical analysis scenario first
    print("Testing statistical analysis scenario...")
    if not test_statistical_analysis_scenario():
        print("Warning: Statistical analysis scenario failed!")
    
    # Test the common plotting scenario
    print("\nTesting most common plotting scenario...")
    if not test_common_plotting_scenario():
        print("Warning: Common plotting scenario failed!")
    
    # First test the server's code execution environment
    print("\nTesting FastAPI server code execution environment...")
    if not test_code_execution_environment():
        return "Server code execution environment test failed!"
    
    # Basic array operations
    print("\nTesting NumPy array operations...")
    arr = np.array([1, 2, 3, 4, 5])
    matrix = np.array([[1, 2], [3, 4]])
    print("Matrix multiplication:", np.dot(matrix, matrix))
    print("Array operations successful")
    
    # Advanced NumPy operations
    print("\nTesting advanced NumPy features...")
    random_data = np.random.normal(0, 1, 1000)
    fft_result = np.fft.fft(random_data)
    print("FFT shape:", fft_result.shape)
    print("Advanced NumPy features successful")
    
    # Pandas operations
    print("\nTesting Pandas operations...")
    dates = pd.date_range(start='2024-01-01', periods=5, freq='D')
    df = pd.DataFrame({
        'date': dates,
        'A': np.random.randn(5),
        'B': np.random.randn(5),
        'category': ['X', 'Y', 'X', 'Y', 'X']
    })
    grouped = df.groupby('category')['A'].mean()
    print("GroupBy result:\n", grouped)
    df.set_index('date', inplace=True)
    print("Rolling mean:\n", df['A'].rolling(window=2).mean())
    print("Pandas operations successful")
    
    # SciPy operations
    print("\nTesting SciPy operations...")
    t_stat, p_val = stats.ttest_ind(df['A'], df['B'])
    print("T-test p-value:", p_val)
    def f(x): return (x[0] - 1)**2 + (x[1] - 2)**2
    result = optimize.minimize(f, [0, 0])
    print("Optimization successful:", result.success)
    x = np.linspace(0, 4, 5)
    y = np.exp(-x/3.0)
    f = interpolate.interp1d(x, y)
    print("Interpolation successful")
    print("SciPy operations successful")
    
    # Matplotlib and Seaborn visualizations
    print("\nTesting visualization libraries...")
    plt.figure(figsize=(12, 8))
    plt.subplot(2, 2, 1)
    sns.regplot(data=df.reset_index(), x='A', y='B')
    plt.subplot(2, 2, 2)
    df['A'].plot()
    plt.subplot(2, 2, 3)
    sns.histplot(data=df, x='A', kde=True)
    plt.subplot(2, 2, 4)
    sns.boxplot(data=df.reset_index(), x='category', y='A')
    plt.tight_layout()
    plt.close()
    print("Visualization tests successful")
    
    # File I/O operations
    print("\nTesting file I/O operations...")
    df.to_csv('test.csv')
    df_read = pd.read_csv('test.csv', index_col=0)
    with open('test.json', 'w') as f:
        json.dump({'test': 'data'}, f)
    print("File I/O operations successful")
    
    # Cleanup test files
    import os
    os.remove('test.csv')
    os.remove('test.json')
    
    return "All dependency tests completed successfully!"

if __name__ == "__main__":
    result = test_all_dependencies()
    print("\nFinal Result:", result) 